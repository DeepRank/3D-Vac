import argparse
import pandas as pd
import glob
import pickle
import os
import traceback
import subprocess
from mpi4py import MPI
import tarfile
import numpy as np
import re

comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()

arg_parser = argparse.ArgumentParser(
    description="""
    Copies target models from db2 into db2_selected_models folder to build db3 on top of them. The default behavior is to select 
    the top1 model generated by PANDORA (ranked in the molpdf.tsv file for each db2 case).
    """
)
arg_parser.add_argument("--structure-rank", "-r",
    help="""
    How many pdb structure to pick from each case. This argument corresponds to the n-th rank. For instance if -r 4,
    the number of structures selected from each case will be the 4 first structures in the molpdf.tsv file. For now,
    This whole pipeline is working only for 1 structure per db2 case. Therefore this argument shouldn't be tweaked, for now.
    Default 1.""",
    default=1,
    type=int,
)
arg_parser.add_argument("--csv-file", "-f",
    help="""
    Name of db1 in data/external/processed/. Default BA_pMHCI.csv.
    """,
    default="../../data/external/processed/BA_pMHCI.csv",
)
arg_parser.add_argument("--mhc-class", "-m",
    help="""
    MHC class
    """,
    default="I",
    choices=["I", "II"],
)

def extract_member(case, member_name):
    try:
        with tarfile.open(f'{case}.tar', 'r') as tar:
            # need to rename tar members because writing to the original dir will not work otherwise
            for member in tar:
                member.name = os.path.basename(member.name)
            os.mkdir(os.join(temp, case))
            tar.extract(member_name, os.join(temp, case))
        # return the full path of tar member
        return os.path.join(temp, case, member_name)
    except tarfile.ReadError as e:
        print(e)
        # remove complete directory so that get_unmodelled cases sees it as unmodelled
        print(f"(unpack archive) Tar file is not valid, removing: {case}")
        subprocess.run(f'rm -r {case}.tar', shell=True, check=True)
        return False
    except subprocess.CalledProcessError as e:
        print('In unpack archive: ')
        print(e)
    except:
        traceback.print_exc()
    assert os.path.exists(case) # if all goes well the tar file should exist
    return True

a = arg_parser.parse_args()

db2_selected_models_path = f"/projects/0/einf2380/data/pMHC{a.mhc_class}/db2_selected_models"
# TMP dir to write temporary files to 
base_tmp = os.environ["TMPDIR"]
temp = os.path.join(base_tmp, "db3_copy_3Dmodels")
if not os.path.exists:
    os.mkdir(temp)

csv_path = f"{a.csv_file}"
df = pd.read_csv(csv_path)

# MANAGE MPI
# ----------

if rank==0:
    # Look only at db2 cases and not every cases:
    all_models = glob.glob(f"/projects/0/einf2380/data/pMHC{a.mhc_class}/3D_models//BA/*/*")
    db2 = np.array([folder for folder in all_models if "_".join(folder.split("/")[-1].split("_")[0:2]) in df["ID"].tolist()])
    db2 = np.array_split(db2, size)
else:
    db2 = None
db2 = comm.scatter(db2, root=0)

# EXECUTE TASK
# ------------

# For each db2 cases, get the best structures:
db2_targets = []
for case in db2:
        molpdf_path = extract_member(case, "molpdf_DOPE.tsv")
        molpdf_df = pd.read_csv(molpdf_path, sep="\t", header=None)
        target_scores = molpdf_df.iloc[:,1].sort_values()[0:a.structure_rank]
        target_mask = [score in target_scores.tolist() for score in molpdf_df.iloc[:,1]]
        target_ids = molpdf_df[target_mask].iloc[:,0]
        targets = [f"{case}/{structure}" for structure in target_ids]
        db2_targets.extend(targets)

# Copy each target:
for structure in db2_targets:
        # extract model from tar so it can be copied
        structure_path = extract_member(case, structure)

        # building the output path
        case_path = "/".join(structure.split("/")[-4:-1])
        pdb_file = structure.split("/")[-1].split('.')
        pdb_file = ('.').join([pdb_file[0], pdb_file[2]])
        destination_dir = f"{db2_selected_models_path}/{case_path}/pdb"
        destination_file = f"{destination_dir}/{pdb_file}"

        if not os.path.isdir(destination_dir):
            try: # create remaining subfolders:
                os.makedirs(destination_dir)
            except:
                print('Something went wrong in creating', destination_dir)
        else:
            print(f"Directory {destination_dir} already exists")
        try: #Copy the pdb file to two files, one to be kept unchanged and one to be modified later
            subprocess.check_call(f'cp {structure_path} {destination_file}', shell=True)
            subprocess.check_call(f'cp {structure_path} {destination_file}.origin', shell=True)
        except Exception as e:
            print(f'The following error occurred: {e}')

# retrieve all db2 to make sure everything is modelled:
print(f"Finished copying on rank {rank} for {db2.shape[0]} cases.")
db2 = comm.gather(db2.shape[0], root=0)
if rank == 0:
    db2 = np.array(db2)
    print(f"Total structures copied: {db2.sum()}")

# remove all the files in the newly created temp folder
subprocess.run(f"rm -r {temp}", shell=True)